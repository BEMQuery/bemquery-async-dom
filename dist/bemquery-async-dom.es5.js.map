{"version":3,"file":"bemquery-async-dom.es5.js","sources":["../src/state.js","../src/batch.js","../src/utils.js","../src/html.js"],"sourcesContent":["'use strict';\n\nimport { BEMQuery as BEMQuery } from 'bemquery-core';\nimport Batch from './batch';\n\nfunction processClasses( converter, element ) {\n\tconst states = [];\n\n\t[].forEach.call( element.classList, ( className ) => {\n\t\tconst state = converter.getStateFromClass( String( className ) );\n\n\t\tif ( state ) {\n\t\t\tstates.push( state );\n\t\t}\n\t} );\n\n\treturn states;\n}\n\n/**\n * Method for getting states from all elements in collection.\n *\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.getStates = function() {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\tconst elements = this.elements;\n\n\tthis.batch.add( 'read', () => {\n\t\tconst result = [];\n\n\t\telements.forEach( ( element ) => {\n\t\t\tresult.push( processClasses( this.converter, element ) );\n\t\t} );\n\n\t\treturn result;\n\t} );\n\n\treturn this;\n};\n","'use strict';\n\n/** Class storing queue of DOM operations. */\nclass Batch {\n\t/**\n\t * Constructing new batch.\n\t *\n\t * @class\n\t */\n\tconstructor() {\n\t\tthis.read = [];\n\t\tthis.write = [];\n\t}\n\n\t/**\n\t * Add new operation to the batch.\n\t *\n\t * @param {String} type Type of operation. Must be either \"read\" or \"write\".\n\t * @param {Function} fn Operation to be fired.\n\t * @return {BEMQuery} Current BEMQuery instance.\n\t */\n\tadd( type, fn ) {\n\n\t\tif ( type !== 'read' && type !== 'write' ) {\n\t\t\tthrow new TypeError( 'Type must be either \\'read\\' or \\'write\\'.' );\n\t\t}\n\n\t\tif ( typeof fn !== 'function' ) {\n\t\t\tthrow new TypeError( 'Task must be a function.' );\n\t\t}\n\n\t\tthis[ type ].push( fn );\n\t}\n\n\t/**\n\t * Run operations of given type.\n\t *\n\t * @param {String} type Type of operations to run. Must be either \"read\" or \"write\".\n\t * @return {Promise} Promise that will be fulfilled after running all tasks.\n\t */\n\trun( type = 'read' ) {\n\t\tif ( type !== 'read' && type !== 'write' ) {\n\t\t\tthrow new TypeError( 'Type must be either \\'read\\' or \\'write\\'.' );\n\t\t}\n\n\t\treturn new Promise( ( resolve ) => {\n\t\t\trequestAnimationFrame( () => {\n\t\t\t\tconst results = [];\n\n\t\t\t\tthis[ type ].forEach( ( fn ) => {\n\t\t\t\t\tresults.push( fn() );\n\t\t\t\t} );\n\n\t\t\t\tthis[ type ] = [];\n\n\t\t\t\treturn resolve( results );\n\t\t\t} );\n\t\t} );\n\t}\n}\n\nexport default Batch;\n","'use strict';\n\nimport { BEMQuery as BEMQuery } from 'bemquery-core';\nimport Batch from './batch';\n\n/**\n * Method that runs all read operations stored in batch\n *\n * @return {Promise} Promise returned by batch.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.read = function() {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\treturn this.batch.run( 'read' );\n};\n\n/**\n * Method that runs all write operations stored in batch\n *\n * @return {Promise} Promise returned by batch.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.write = function() {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\treturn this.batch.run( 'write' );\n};\n","'use strict';\n\nimport { BEMQuery as BEMQuery } from 'bemquery-core';\nimport Batch from './batch';\n\n/**\n * Method for getting/setting inner HTML of all elements in collection\n *\n * @param {String} [newHTML] The new inner HTML value. If not specified,\n * the method will work as getter.\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.html = function( newHTML ) {\n\tif ( !this.batch ) {\n\t\tthis.batch = new Batch();\n\t}\n\n\tif ( typeof newHTML !== 'undefined' ) {\n\t\tnewHTML = String( newHTML );\n\n\t\tthis.batch.add( 'write', () => {\n\t\t\tconst elements = this.elements;\n\n\t\t\telements.forEach( ( element ) => {\n\t\t\t\telement.innerHTML = newHTML;\n\t\t\t} );\n\t\t} );\n\t} else {\n\t\tthis.batch.add( 'read', () => {\n\t\t\tconst elements = this.elements;\n\t\t\tconst htmls = [];\n\n\t\t\telements.forEach( ( element ) => {\n\t\t\t\thtmls.push( element.innerHTML );\n\t\t\t} );\n\n\t\t\treturn htmls;\n\t\t} );\n\t}\n\n\treturn this;\n};\n"],"names":["processClasses","converter","element","states","forEach","call","classList","className","state","getStateFromClass","String","push","Batch","read","write","type","fn","TypeError","Promise","resolve","results","BEMQuery","prototype","this","batch","run","html","newHTML","add","elements","_this","innerHTML","htmls","getStates","result"],"mappings":";8MAKA,SAASA,GAAgBC,EAAWC,MAC7BC,eAEHC,QAAQC,KAAMH,EAAQI,UAAW,SAAEC,MAC/BC,GAAQP,EAAUQ,kBAAmBC,OAAQH,GAE9CC,MACGG,KAAMH,KAIRL,0VCbFS,yCAOCC,aACAC,+CAUDC,EAAMC,MAEI,SAATD,GAA4B,UAATA,OACjB,IAAIE,WAAW,6CAGH,kBAAPD,QACL,IAAIC,WAAW,iCAGhBF,GAAOJ,KAAMK,4CASfD,yDAAO,UACG,SAATA,GAA4B,UAATA,OACjB,IAAIE,WAAW,gDAGf,IAAIC,SAAS,SAAEC,yBACE,cAChBC,eAEAL,GAAOX,QAAS,SAAEY,KACfL,KAAMK,SAGTD,MAECI,EAASC,eC5CpBC,YAASC,UAAUT,KAAO,iBACnBU,MAAKC,aACLA,MAAQ,GAAIZ,IAGXW,KAAKC,MAAMC,IAAK,SASxBJ,WAASC,UAAUR,MAAQ,iBACpBS,MAAKC,aACLA,MAAQ,GAAIZ,IAGXW,KAAKC,MAAMC,IAAK,UCjBxBJ,WAASC,UAAUI,KAAO,SAAUC,oBAC7BJ,MAAKC,aACLA,MAAQ,GAAIZ,IAGM,mBAAZe,MACDjB,OAAQiB,QAEbH,MAAMI,IAAK,QAAS,cAClBC,GAAWC,EAAKD,WAEbzB,QAAS,SAAEF,KACX6B,UAAYJ,YAIjBH,MAAMI,IAAK,OAAQ,cACjBC,GAAWC,EAAKD,SAChBG,cAEG5B,QAAS,SAAEF,KACbS,KAAMT,EAAQ6B,aAGdC,IAIFT,MHhBRF,WAASC,UAAUW,UAAY,qBACxBV,MAAKC,aACLA,MAAQ,GAAIZ,OAGZiB,GAAWN,KAAKM,qBAEjBL,MAAMI,IAAK,OAAQ,cACjBM,eAEG9B,QAAS,SAAEF,KACZS,KAAMX,EAAgB8B,EAAK7B,UAAWC,MAGvCgC,IAGDX"}